# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rP9CvLvbHHFuya02w3YsmJFMB5qwStCV
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.neighbors import NearestNeighbors

st.set_page_config(page_title="Movie Recommender", layout="wide")

st.title("Movie Recommendation System")


# Load Data

@st.cache_data
def load_data():
    movies = pd.read_csv("movies.csv")
    ratings = pd.read_csv("ratings_sample.csv")
    return movies, ratings

movies, ratings = load_data()


# Popularity-Based Model

@st.cache_data
def compute_popularity(ratings, movies):
    movie_stats = ratings.groupby("movieId").agg(
        mean_rating=("rating", "mean"),
        rating_count=("rating", "count")
    ).reset_index()

    global_mean = movie_stats["mean_rating"].mean()
    m = movie_stats["rating_count"].quantile(0.75)

    movie_stats["popularity_score"] = (
        (movie_stats["rating_count"] / (movie_stats["rating_count"] + m)) * movie_stats["mean_rating"]
        + (m / (movie_stats["rating_count"] + m)) * global_mean
    )

    return movie_stats.merge(movies, on="movieId")

popular_movies = compute_popularity(ratings, movies)


# KNN Similarity Model

@st.cache_data
def build_knn(movies, ratings):
    rated_movies = ratings["movieId"].unique()
    movies_filtered = movies[movies["movieId"].isin(rated_movies)]

    genre_features = movies_filtered["genres"].str.get_dummies(sep="|")

    knn = NearestNeighbors(metric="cosine", n_neighbors=6)
    knn.fit(genre_features)

    return movies_filtered, genre_features, knn

movies_knn, genre_features, knn_model = build_knn(movies, ratings)


# UI: Popular Movies

st.subheader("Top Popular Movies")
st.dataframe(
    popular_movies.sort_values("popularity_score", ascending=False)
    [["title", "mean_rating", "rating_count"]]
    .head(10)
)


# UI: Similar Movies

st.subheader("Find Similar Movies")

movie_input = st.text_input("Enter a movie title")

if movie_input:
    matches = movies_knn[movies_knn["title"].str.contains(movie_input, case=False, regex=False)]

    if matches.empty:
        st.warning("Movie not found.")
    else:
        idx = matches.index[0]
        distances, indices = knn_model.kneighbors(
            genre_features.iloc[idx].values.reshape(1, -1)
        )

        recommended = movies_knn.iloc[indices[0][1:]][["title", "genres"]]
        st.write(recommended)